/*******************************************************************************
 * Copyright (c) 2018 École Polytechnique de Montréal
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/

package org.eclipse.tracecompass.incubator.time.partitioning.core.cgroup;

import java.util.Collections;

import static org.eclipse.tracecompass.common.core.NonNullUtils.checkNotNull;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.tracecompass.common.core.NonNullUtils;
import org.eclipse.tracecompass.statesystem.core.ITmfStateSystem;
import org.eclipse.tracecompass.statesystem.core.exceptions.StateSystemDisposedException;
import org.eclipse.tracecompass.tmf.core.analysis.requirements.TmfAbstractAnalysisRequirement;
import org.eclipse.tracecompass.tmf.core.statesystem.ITmfStateProvider;
import org.eclipse.tracecompass.tmf.core.statesystem.TmfStateSystemAnalysisModule;
import org.eclipse.tracecompass.tmf.core.trace.ITmfTrace;
import org.eclipse.tracecompass.tmf.core.trace.experiment.TmfExperiment;

/**
 * Container analysis. Creates a unique state system for control
 * groups by reading UST events generated by a custom-made deamon.
 *
 * @author Loïc Gelle
 */
public class ContainerAnalysis extends TmfStateSystemAnalysisModule {

    /** The ID of this analysis module */
    public static final String ID = "org.eclipse.tracecompass.incubator.time.partitioning.core.cgroup.analysis"; //$NON-NLS-1$

    @Override
    protected @NonNull ITmfStateProvider createStateProvider() {
        return new ContainerStateProvider((TmfExperiment) checkNotNull(getTrace()));
    }

    @Override
    public boolean canExecute(ITmfTrace trace) {
        return (trace instanceof TmfExperiment) && super.canExecute(trace);
    }

    @Override
    protected String getFullHelpText() {
        return NonNullUtils.nullToEmptyString("Tracks the state of control groups and containers."); //$NON-NLS-1$
    }

    @Override
    public Iterable<TmfAbstractAnalysisRequirement> getAnalysisRequirements() {
        return Collections.emptySet();
    }

    /**
     *
     * @param tid
     *          ID of the thread for which to find the cgroup.
     * @param time
     *          The time in nanoseconds.
     * @return
     *          The current cgroup name (path in the filesystem) at the time or {@code null} if
     *          not known.
     */
    public @Nullable String getCpuControllerCgroup(long tid, long time) {
        ITmfStateSystem stateSystem = getStateSystem();
        if (stateSystem == null || time < stateSystem.getStartTime()) {
            return null;
        }

        int cgroupQuark = stateSystem.optQuarkAbsolute(ContainerAttributes.CGROUPS_PIDS, Long.toString(tid),
                "cpu"); //$NON-NLS-1$

        if (cgroupQuark == ITmfStateSystem.INVALID_ATTRIBUTE) {
            return null;
        }

        Object objCgroup = null;
        try {
            objCgroup = stateSystem.querySingleState(time, cgroupQuark).getValue();
        } catch (StateSystemDisposedException e) {
            return null;
        }

        if (!(objCgroup instanceof String)) {
            return null;
        }

        return (String)objCgroup;
    }
}
